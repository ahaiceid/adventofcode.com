#!/usr/bin/python3
from functools import reduce
from math import prod

MACHINE1 = {
    # initial state: a tuple containing horizontal distance, depth
    "init":     (0,0),
    # evaluation function: returns horizontal distance * depth
    "evaluate": lambda st: (st[0] * st[1]),
    # operations the machine can perform to generate new states
    "forward":  lambda st, op: (st[0] + op, st[1]),
    "down":     lambda st, op: (st[0], st[1] + op),
    "up":       lambda st, op: (st[0], st[1] - op),
}

MACHINE2 = {
    # initial state: a tuple containing horizontal distance, depth, aim
    "init":     (0,0,0),
    # evaluation function: returns horizontal distance * depth
    "evaluate": lambda st: (st[0] * st[1]),
    # operations the machine can perform to generate new states
    "forward":  lambda st, op: (st[0] + op, st[1] + st[2] * op, st[2]),
    "down":     lambda st, op: (st[0], st[1], st[2] + op),
    "up":       lambda st, op: (st[0], st[1], st[2] - op),
}

def processor(machine):
    ''' A functor which returns a processor function for the given machine'''
    def f(state, input):
        ''' Apply the input to the state

        Arguments:
            state -- a state which can be passed to the machine operation
            input -- a list containing the operator and an operand

        Returns the state generated by applying the input to the state.
        '''
        nonlocal machine
        return machine[input[0]](state, int(input[1]))
    return f

if __name__ == "__main__":
    with open("input") as fh:
        # This operation uses the functools.reduce function to call a
        # function returned by processor(MACHINE1) repeatedly.
        #   In layman's terms it starts by using the MACHINE1["init"]
        # state with the first input from the file, generating a new
        # state. That state is then used with the second input from
        # the file and so on, repeating until all inputs have been
        # applied and a final state is generated.
        #   The MACHINE1["evaluate"] function is used to calculate an
        # output based on that final state meeting the requirements of
        # the challenge question (final horizontal distance * depth).
        print(
            MACHINE1["evaluate"](
                reduce(
                    processor(MACHINE1),
                    [ln.strip().split() for ln in fh.readlines()],
                    MACHINE1["init"]
                )
            )
        )
    with open("input") as fh:
        print(
            MACHINE2["evaluate"](
                reduce(
                    processor(MACHINE2),
                    [ln.strip().split() for ln in fh.readlines()],
                    MACHINE2["init"]
                )
            )
        )

